// Generated by CoffeeScript 1.10.0
(function() {
  var DOM, DOMCreate, Himesama, Merge, _, allocateIds, createElement, createTextNode, getByAttribute, getElementById, hk, htmlify, querySelector, querySelectorAll, ref, textAreas,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = require('lodash');

  htmlify = require('./htmlify');

  Merge = require('./merge');

  ref = require('./doc'), getElementById = ref.getElementById, createTextNode = ref.createTextNode, createElement = ref.createElement, querySelectorAll = ref.querySelectorAll, querySelector = ref.querySelector, getByAttribute = ref.getByAttribute;

  hk = 'himesama-id';

  textAreas = ['text', 'textarea'];

  DOMCreate = function(type) {
    return function() {
      var args;
      args = _.toArray(arguments);
      if (args[0] == null) {
        args[0] = {};
      }
      return _.reduce(_.flatten(args.slice(1)), function(vo, child, i) {
        if (_.isString(child)) {
          child = {
            type: 'himesama-text',
            content: child
          };
        }
        child.parent = vo;
        child.index = i;
        vo.children.push(child);
        return vo;
      }, {
        type: type,
        attributes: args[0],
        children: []
      });
    };
  };

  allocateIds = require('./allocate-ids.coffee');

  Himesama = {
    createClass: function(c) {
      return function() {
        var H, attributes, needs;
        H = {};
        _.forEach(_.keys(c), function(k) {
          var v;
          v = c[k];
          if (_.isFunction(v)) {
            v = v.bind(H);
          }
          H[k] = v;
        });
        H.setAttr = function(payload, next) {
          this.dirty = true;
          _.forEach(_.keys(payload), (function(_this) {
            return function(k) {
              return _this.attributes[k] = payload[k];
            };
          })(this));
          return Himesama.rerender(this);
        };
        attributes = arguments[0];
        needs = arguments[1];
        H.attributes = {};
        if (H.initAttributes != null) {
          H.attributes = H.initAttributes();
        }
        _.forEach(_.keys(attributes), (function(_this) {
          return function(k) {
            return H.attributes[k] = attributes[k];
          };
        })(this));
        if (needs != null) {
          if (H.needs != null) {
            H.needs = H.needs.concat(needs);
          } else {
            H.needs = needs;
          }
        }
        H.dirty = false;
        H.setState = Himesama.setState.bind(Himesama);
        H.state = Himesama.state;
        H.type = 'custom';
        H.children = [H.render()];
        return H;
      };
    },
    initState: function(state) {
      return this.state = state;
    },
    setState: function(payload, next) {
      var keys;
      keys = _.keys(payload);
      _.forEach(keys, (function(_this) {
        return function(k) {
          _this.state[k] = payload[k];
        };
      })(this));
      _.forEach(keys, (function(_this) {
        return function(k) {
          return _this.dirtify(_this.vdom, k);
        };
      })(this));
      this.rerender(this.vdom);
      return typeof next === "function" ? next() : void 0;
    },
    Render: function(vdom, mount) {
      var html;
      allocateIds(vdom, '0');
      this.vdom = vdom;
      this.mount = mount;
      html = htmlify(this.vdom);
      return mount.appendChild(html);
    },
    dirtify: function(node, basis) {
      var children, needs;
      needs = node.needs, children = node.children;
      if ((needs != null) && indexOf.call(needs, basis) >= 0) {
        node.dirty = true;
      }
      return _.forEach(children, (function(_this) {
        return function(child, ci) {
          return _this.dirtify(child, basis);
        };
      })(this));
    },
    rerender: function(node) {
      var children, dirty, draft, itsChild;
      dirty = node.dirty, children = node.children;
      if ((dirty != null) && dirty) {
        node.dirty = false;
        draft = node.render();
        itsChild = node.children[0];
        draft.index = itsChild.index;
        draft.parent = itsChild.parent;
        this.saveActiveText();
        Merge(node, draft);
        return this.loadActiveText();
      } else {
        return _.forEach(children, (function(_this) {
          return function(child) {
            return _this.rerender(child);
          };
        })(this));
      }
    },
    saveActiveText: function() {
      var el, ref1;
      el = document.activeElement;
      this.activesId = el.getAttribute(hk);
      if (ref1 = el.type, indexOf.call(textAreas, ref1) >= 0) {
        this.textStart = el.selectionStart;
        return this.textEnd = el.selectionEnd;
      }
    },
    loadActiveText: function() {
      var el, ref1;
      el = getByAttribute(hk, this.activesId);
      if (el != null) {
        el.focus();
        if (ref1 = el.type, indexOf.call(textAreas, ref1) >= 0) {
          return el.setSelectionRange(this.textStart, this.textEnd);
        }
      }
    }
  };

  Himesama.initState = Himesama.initState.bind(Himesama);

  Himesama.Render = Himesama.Render.bind(Himesama);

  DOM = (require('./dom-elements')).split(' ');

  DOM.unshift({});

  Himesama.DOM = _.reduce(DOM, function(sum, el) {
    sum[el] = DOMCreate(el);
    return sum;
  });

  module.exports = Himesama;

}).call(this);
